/// <reference types="react" />
type ClientSize = {
    clientHeight?: number;
    clientWidth?: number;
};
type ScrollSize = {
    scrollHeight?: number;
    scrollWidth?: number;
};
type ScrollPosition = {
    scrollLeft?: number;
    scrollTop?: number;
};
interface Dataset {
    rowCount?: number;
    columnCount?: number;
}
type ScrollParams = ScrollSize & ScrollPosition & ClientSize;
type EventListenerFn = (type: 'scroll', callback: () => void) => void;

declare enum ScrollAxisName {
    VERTICAL = "vertical",
    HORIZONTAL = "horizontal"
}
declare enum ScrollDirection {
    UP = "up",
    DOWN = "down",
    LEFT = "left",
    RIGHT = "right"
}

type ScrollAxis<T> = {
    [ScrollAxisName.VERTICAL]?: T;
    [ScrollAxisName.HORIZONTAL]?: T;
};
type ScrollDirectionState<T> = Partial<Record<ScrollDirection, T>>;

type SetRefFn = <T = any>(ref: T) => void;
type ScrollingElementRef = Required<ScrollParams>;
type RegisterEventListener = {
    addEventListener: EventListenerFn;
    removeEventListener: EventListenerFn;
};
type ScrollingContainerRef = {
    scrollingElement: ScrollingElementRef | null;
    registerEventListener: RegisterEventListener | null;
};
type VirtualizedScrollingContainer = {
    _scrollingContainer: HTMLElement;
};
type VirtualizedGrid = {
    Grid: VirtualizedScrollingContainer;
};
type ElementRef = VirtualizedScrollingContainer | VirtualizedGrid | HTMLElement;
type InfiniteScrollRef<T> = React.MutableRefObject<T | null>;
type ScrollDirectionBooleanState = ScrollDirectionState<boolean>;
type ScrollOffsetValues = Required<ScrollDirectionBooleanState>;
type InfiniteScrollState = Dataset & Required<ScrollSize> & Required<ClientSize> & {
    isLoading: boolean;
    thresholdReached: ScrollDirectionBooleanState;
    computedScrollThreshold: Required<ScrollAxis<number>>;
    cleanup: (() => void)[];
};
type InfiniteScrollProps = Dataset & {
    hasMore: ScrollDirectionBooleanState;
    next: (direction: ScrollDirection) => Promise<void>;
    onScroll?: (value: Required<ScrollParams>) => void;
    scrollThreshold?: number | string;
    initialScroll?: {
        top?: number;
        left?: number;
    };
    reverse?: {
        column?: boolean;
        row?: boolean;
    };
    windowScroll?: boolean;
};

declare class InfiniteScroll {
    props: InfiniteScrollProps;
    state: InfiniteScrollState;
    _scrollingContainerRef?: ScrollingContainerRef;
    constructor(props: InfiniteScrollProps);
    _setRef: (this: InfiniteScroll, ref: ElementRef | null) => void;
    _onPropsChange: (this: InfiniteScroll, props: InfiniteScrollProps) => void;
    _onCleanup: (this: InfiniteScroll) => void;
    setRef: (ref: ElementRef | null) => void;
    onPropsChange: (props: InfiniteScrollProps) => void;
    onCleanup: () => void;
}

declare const checkOffsetAndLoadMore: (ctx: InfiniteScroll) => void;

declare const computeThreshold: (ctx: InfiniteScroll) => void;

type GetPossibleLoadDirectionsArgs = {
    offset?: number;
};
declare const getPossibleLoadDirections: (ctx: InfiniteScroll, args?: GetPossibleLoadDirectionsArgs) => Required<ScrollOffsetValues>;

type LoadByDirectionArgs = {
    positiveDirection: ScrollDirection.UP | ScrollDirection.LEFT;
    negativeDirection: ScrollDirection.DOWN | ScrollDirection.RIGHT;
    offset: Required<ScrollOffsetValues>;
    loadMore: (ctx: InfiniteScroll) => void;
};
declare const loadByDirection: (ctx: InfiniteScroll, { positiveDirection, negativeDirection, offset, loadMore }: LoadByDirectionArgs) => Promise<void>;

type OnLoadCompleteArgs = {
    axis: ScrollAxisName;
    loadMore: (ctx: InfiniteScroll) => void;
};
declare const onLoadComplete: (ctx: InfiniteScroll, { axis, loadMore }: OnLoadCompleteArgs) => void;

type ResetReachedThresholdArgs = {
    direction: ScrollDirection;
    offset?: number;
    hardReset?: boolean;
};
declare const resetReachedThreshold: (ctx: InfiniteScroll, { direction, offset, hardReset }: ResetReachedThresholdArgs) => void;

declare const scroll: (ctx: InfiniteScroll, { scrollTop, scrollLeft }: ScrollPosition) => void;

type GetValidScrollValueArgs = {
    newValue: number;
    scrollSize: number;
    fallbackValue?: number;
};
declare const getValidScrollValue: ({ newValue, scrollSize, fallbackValue }: GetValidScrollValueArgs) => number;

declare const getMultiplierSign: (value?: number | boolean) => number;

type GetScrollingContainerRefArgs = {
    ref: ElementRef | null;
    windowScroll?: boolean;
};
declare const getScrollingContainerRef: ({ ref, windowScroll, }: GetScrollingContainerRefArgs) => ScrollingContainerRef;

declare const isValidScrollingContainerRef: (ref: ScrollingContainerRef) => boolean;

declare const useInfiniteScroll: <T>(props: InfiniteScrollProps) => InfiniteScrollRef<T>;

export { ClientSize, Dataset, ElementRef, EventListenerFn, GetPossibleLoadDirectionsArgs, GetScrollingContainerRefArgs, GetValidScrollValueArgs, InfiniteScroll, InfiniteScrollProps, InfiniteScrollRef, InfiniteScrollState, LoadByDirectionArgs, OnLoadCompleteArgs, RegisterEventListener, ResetReachedThresholdArgs, ScrollAxis, ScrollAxisName, ScrollDirection, ScrollDirectionBooleanState, ScrollDirectionState, ScrollOffsetValues, ScrollParams, ScrollPosition, ScrollSize, ScrollingContainerRef, ScrollingElementRef, SetRefFn, VirtualizedGrid, VirtualizedScrollingContainer, checkOffsetAndLoadMore, computeThreshold, useInfiniteScroll as default, getMultiplierSign, getPossibleLoadDirections, getScrollingContainerRef, getValidScrollValue, isValidScrollingContainerRef, loadByDirection, onLoadComplete, resetReachedThreshold, scroll };
