{"ast":null,"code":"/**\n * Helper functions for API requests\n */const apiURL='http://localhost:2500/';/**\n * Fetches users from the API.\n * @returns {Promise} - Promise resolving to users objects.\n */export const getUsers=async()=>{const response=await fetch(`${apiURL}users/`);return response.json();};/**\n * Fetches user data from the API.\n * @returns {Promise} - Promise resolving to user objects.\n */export const getUser=async id=>{const response=await fetch(`${apiURL}users/${id}`);return response.json();};export const saveUser=async user=>{let response=await fetch(`${apiURL}users/${user.id}`,{method:'PUT',headers:{'Content-Type':'application/json'},body:JSON.stringify(user)});return await response.json();};/**\n * Fetches users tasks from the API.\n * @returns {Promise} - Promise resolving to the tasks object.\n */export const getTasks=async userID=>{try{const response=await fetch(`${apiURL}tasks/`);const tasks=await response.json();// Filter tasks based on userID\nconst filtered=tasks.filter(task=>parseInt(task.userID,10)===parseInt(userID,10));return filtered.map(task=>{let parsedSubtasks=[];if(typeof task.subtasks===\"string\"){try{parsedSubtasks=JSON.parse(task.subtasks);}catch(error){console.error(\"Error parsing subtasks for task ID:\",task.id,error);}}else{parsedSubtasks=task.subtasks;}return{...task,subtasks:parsedSubtasks};});}catch(error){console.log('Error when fetching user tasks:',error);}};/**\n * Fetches users task from the API.\n * @returns {Promise} - Promise resolving to the task object.\n */export const getTask=async(userID,taskID)=>{try{const response=await fetch(`${apiURL}tasks/${taskID}`);const task=await response.json();const usersTask=task.find(e=>e.userID===userID);if(!usersTask){throw new Error(`Task not found for user ID: ${userID}`);}let parsedSubtasks=[];if(typeof usersTask.subtasks===\"string\"){try{parsedSubtasks=JSON.parse(usersTask.subtasks);}catch(error){console.error(\"Error parsing subtasks for task ID:\",taskID,error);}}else{parsedSubtasks=usersTask.subtasks;}return{...usersTask,subtasks:parsedSubtasks};}catch(error){console.error('Error when fetching user task:',error);}};export const saveTask=async task=>{try{// Try to update the task\nlet response=await fetch(`${apiURL}tasks/${task.taskID}`,{method:'PUT',headers:{'Content-Type':'application/json'},body:JSON.stringify(task)});// If the task does not exist, create a new task\nif(response.status===404){response=await fetch(`${apiURL}tasks/`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(task)});}// Return the response data\nreturn await response.json();}catch(error){console.error('An error occurred:',error);throw error;}};/**\n * Delete a task from the API.\n * @param {string} taskID - The ID of the task data.\n * @returns {Promise} - Promise resolving to the parsed JSON data.\n */export const deleteTask=async taskID=>{try{const response=await fetch(`${apiURL}tasks/${taskID}`,{method:'DELETE',headers:{'Content-Type':'application/json'}});if(response.status===404){console.log(\"Task does not exist in database\");}return;}catch(error){console.log(\"Task deleted\");}};/**\n * Delete a user from the API.\n * @param {string} userID - The ID of the user data.\n * @returns {Promise} - Promise resolving to the parsed JSON data.\n */export const deleteUser=async userID=>{return fetch(`${apiURL}users/${userID}`,{method:'DELETE',headers:{'Content-Type':'application/json'}});};// troubleshooting\nexport const deleteChannel=async channelID=>{try{const exists=await existsOnChannelsApi(channelID);console.log(`Channel exists: ${exists}`);if(exists){const response=await fetch(`${apiURL}channels/${channelID}`,{method:'DELETE',headers:{'Content-Type':'application/json'}});if(!response.ok){console.error(`Failed to delete channel. Status: ${response.status}`);}else{console.log('Channel deleted successfully');}return response;}else{console.log('Channel does not exist');}}catch(error){console.error('Error deleting channel:',error);}};export const saveChannel=async channel=>{const exists=await existsOnChannelsApi(channel.channelID);// save as new channel on API\nif(!exists){let response=await fetch(`${apiURL}channels/`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(channel)});return await response.json();}else{// update channel entry on API\nlet response=await fetch(`${apiURL}channels/${channel.channelID}`,{method:'PUT',headers:{'Content-Type':'application/json'},body:JSON.stringify(channel)});return await response.json();}};/**\n * Fetches users channels from the API.\n * @returns {Promise} - Promise resolving to the tasks object.\n */export const getChannels=async userID=>{try{const response=await fetch(`${apiURL}channels/`);const channels=await response.json();return channels.filter(channel=>channel.userID===userID);}catch(error){console.error('Error when fetching users channels',error);}};export const existsOnChannelsApi=async channelID=>{try{const response=await fetch(`${apiURL}channels/${channelID}`);return response.ok?true:false;}catch(error){console.error(\"Error:\",error);return false;}};export const requestLogin=async response=>{const token=response.credential;try{const serverResponse=await fetch(`${apiURL}login/callback`,{method:'POST',headers:{'Content-Type':'application/json'},credentials:'include',body:JSON.stringify({token})});localStorage.setItem('access_token',token);return await serverResponse.json();}catch(error){console.error('Login failed:',error);}};","map":{"version":3,"names":["apiURL","getUsers","response","fetch","json","getUser","id","saveUser","user","method","headers","body","JSON","stringify","getTasks","userID","tasks","filtered","filter","task","parseInt","map","parsedSubtasks","subtasks","parse","error","console","log","getTask","taskID","usersTask","find","e","Error","saveTask","status","deleteTask","deleteUser","deleteChannel","channelID","exists","existsOnChannelsApi","ok","saveChannel","channel","getChannels","channels","requestLogin","token","credential","serverResponse","credentials","localStorage","setItem"],"sources":["/Users/jasmineburt/Documents/projects/projects/pixel/src/data/api.js"],"sourcesContent":["/**\n * Helper functions for API requests\n */\n\nconst apiURL = 'http://localhost:2500/'\n\n/**\n * Fetches users from the API.\n * @returns {Promise} - Promise resolving to users objects.\n */\nexport const getUsers = async () => {\n  const response = await fetch(`${apiURL}users/`);\n  return response.json();\n};\n\n/**\n * Fetches user data from the API.\n * @returns {Promise} - Promise resolving to user objects.\n */\nexport const getUser = async (id) => {\n  const response = await fetch(`${apiURL}users/${id}`);\n  return response.json();\n};\n\nexport const saveUser = async (user) => {\n  let response = await fetch(`${apiURL}users/${user.id}`, {\n    method: 'PUT',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(user),\n  });\n  return await response.json();\n}\n\n/**\n * Fetches users tasks from the API.\n * @returns {Promise} - Promise resolving to the tasks object.\n */\nexport const getTasks = async (userID) => {\n  try {\n    const response = await fetch(`${apiURL}tasks/`);\n    const tasks = await response.json();\n\n    // Filter tasks based on userID\n    const filtered = tasks.filter((task) => parseInt(task.userID, 10) === parseInt(userID, 10));\n\n    return filtered.map((task) => {\n      let parsedSubtasks = [];\n      if ((typeof (task.subtasks)) === \"string\") {\n        try {\n          parsedSubtasks = JSON.parse(task.subtasks);\n        } catch (error) {\n          console.error(\"Error parsing subtasks for task ID:\", task.id, error);\n        }\n      } else {\n        parsedSubtasks = task.subtasks;\n      }\n      return {\n        ...task,\n        subtasks: parsedSubtasks,\n      };\n    });\n  } catch (error) {\n    console.log('Error when fetching user tasks:', error);\n  }\n};\n\n\n/**\n * Fetches users task from the API.\n * @returns {Promise} - Promise resolving to the task object.\n */\nexport const getTask = async (userID, taskID) => {\n  try {\n    const response = await fetch(`${apiURL}tasks/${taskID}`);\n    const task = await response.json();\n\n    const usersTask = task.find((e) => e.userID === userID);\n\n    if (!usersTask) {\n      throw new Error(`Task not found for user ID: ${userID}`);\n    }\n\n    let parsedSubtasks = [];\n    if (typeof usersTask.subtasks === \"string\") {\n      try {\n        parsedSubtasks = JSON.parse(usersTask.subtasks);\n      } catch (error) {\n        console.error(\"Error parsing subtasks for task ID:\", taskID, error);\n      }\n    } else {\n      parsedSubtasks = usersTask.subtasks;\n    }\n    return {\n      ...usersTask,\n      subtasks: parsedSubtasks, \n    };\n\n  } catch (error) {\n    console.error('Error when fetching user task:', error);\n  }\n};\n\nexport const saveTask = async (task) => {\n\n  try {\n    // Try to update the task\n    let response = await fetch(`${apiURL}tasks/${task.taskID}`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(task),\n    });\n\n    // If the task does not exist, create a new task\n    if (response.status === 404) {\n      response = await fetch(`${apiURL}tasks/`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(task),\n      });\n    }\n\n    // Return the response data\n    return await response.json();\n  } catch (error) {\n    console.error('An error occurred:', error);\n    throw error;\n  }\n};\n\n\n/**\n * Delete a task from the API.\n * @param {string} taskID - The ID of the task data.\n * @returns {Promise} - Promise resolving to the parsed JSON data.\n */\nexport const deleteTask = async (taskID) => {\n  try {\n    const response = await fetch(`${apiURL}tasks/${taskID}`, {\n      method: 'DELETE',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n    if (response.status === 404) {\n      console.log(\"Task does not exist in database\")\n    }\n    return;\n  } catch (error) {\n    console.log(\"Task deleted\");\n  }\n}\n\n/**\n * Delete a user from the API.\n * @param {string} userID - The ID of the user data.\n * @returns {Promise} - Promise resolving to the parsed JSON data.\n */\nexport const deleteUser = async (userID) => {\n    return fetch(`${apiURL}users/${userID}`, {\n      method: 'DELETE',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    })\n}\n\n// troubleshooting\n\nexport const deleteChannel = async (channelID) => {\n  try {\n    const exists = await existsOnChannelsApi(channelID);\n    console.log(`Channel exists: ${exists}`);\n\n    if (exists) {\n      const response = await fetch(`${apiURL}channels/${channelID}`, {\n        method: 'DELETE',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      if (!response.ok) {\n        console.error(`Failed to delete channel. Status: ${response.status}`);\n      } else {\n        console.log('Channel deleted successfully');\n      }\n\n      return response;\n    } else {\n      console.log('Channel does not exist');\n    }\n  } catch (error) {\n    console.error('Error deleting channel:', error);\n  }\n};\n\nexport const saveChannel = async (channel) => {\n  const exists = await existsOnChannelsApi(channel.channelID);\n\n  // save as new channel on API\n  if (!exists) {\n    let response = await fetch(`${apiURL}channels/`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(channel),\n    });\n    return await response.json();\n  } else {\n    // update channel entry on API\n    let response = await fetch(`${apiURL}channels/${channel.channelID}`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(channel),\n    });\n    return await response.json();\n  }\n}\n\n/**\n * Fetches users channels from the API.\n * @returns {Promise} - Promise resolving to the tasks object.\n */\nexport const getChannels = async (userID) => {\n  try {\n    const response = await fetch(`${apiURL}channels/`);\n    const channels = await response.json();\n    return channels.filter((channel) => (\n      channel.userID === userID\n    ));\n  } catch (error) {\n    console.error('Error when fetching users channels', error);\n  }\n}\n\nexport const existsOnChannelsApi = async (channelID) => {\n  try {\n    const response = await fetch(`${apiURL}channels/${channelID}`);\n    return response.ok ? true : false;\n  } catch (error) {\n    console.error(\"Error:\", error);\n    return false;\n  }\n}\n\nexport const requestLogin = async (response) => {\n  const token = response.credential;\n  \n  try {\n    const serverResponse = await fetch(`${apiURL}login/callback`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      credentials: 'include',\n      body: JSON.stringify({ token }),\n    });\n    localStorage.setItem('access_token', token);\n    return await serverResponse.json();\n  } catch (error) {\n    console.error('Login failed:', error);\n  }\n};\n"],"mappings":"AAAA;AACA;AACA,GAEA,KAAM,CAAAA,MAAM,CAAG,wBAAwB,CAEvC;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAC,QAAQ,CAAG,KAAAA,CAAA,GAAY,CAClC,KAAM,CAAAC,QAAQ,CAAG,KAAM,CAAAC,KAAK,CAAC,GAAGH,MAAM,QAAQ,CAAC,CAC/C,MAAO,CAAAE,QAAQ,CAACE,IAAI,CAAC,CAAC,CACxB,CAAC,CAED;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAC,OAAO,CAAG,KAAO,CAAAC,EAAE,EAAK,CACnC,KAAM,CAAAJ,QAAQ,CAAG,KAAM,CAAAC,KAAK,CAAC,GAAGH,MAAM,SAASM,EAAE,EAAE,CAAC,CACpD,MAAO,CAAAJ,QAAQ,CAACE,IAAI,CAAC,CAAC,CACxB,CAAC,CAED,MAAO,MAAM,CAAAG,QAAQ,CAAG,KAAO,CAAAC,IAAI,EAAK,CACtC,GAAI,CAAAN,QAAQ,CAAG,KAAM,CAAAC,KAAK,CAAC,GAAGH,MAAM,SAASQ,IAAI,CAACF,EAAE,EAAE,CAAE,CACtDG,MAAM,CAAE,KAAK,CACbC,OAAO,CAAE,CACP,cAAc,CAAE,kBAClB,CAAC,CACDC,IAAI,CAAEC,IAAI,CAACC,SAAS,CAACL,IAAI,CAC3B,CAAC,CAAC,CACF,MAAO,MAAM,CAAAN,QAAQ,CAACE,IAAI,CAAC,CAAC,CAC9B,CAAC,CAED;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAU,QAAQ,CAAG,KAAO,CAAAC,MAAM,EAAK,CACxC,GAAI,CACF,KAAM,CAAAb,QAAQ,CAAG,KAAM,CAAAC,KAAK,CAAC,GAAGH,MAAM,QAAQ,CAAC,CAC/C,KAAM,CAAAgB,KAAK,CAAG,KAAM,CAAAd,QAAQ,CAACE,IAAI,CAAC,CAAC,CAEnC;AACA,KAAM,CAAAa,QAAQ,CAAGD,KAAK,CAACE,MAAM,CAAEC,IAAI,EAAKC,QAAQ,CAACD,IAAI,CAACJ,MAAM,CAAE,EAAE,CAAC,GAAKK,QAAQ,CAACL,MAAM,CAAE,EAAE,CAAC,CAAC,CAE3F,MAAO,CAAAE,QAAQ,CAACI,GAAG,CAAEF,IAAI,EAAK,CAC5B,GAAI,CAAAG,cAAc,CAAG,EAAE,CACvB,GAAK,MAAQ,CAAAH,IAAI,CAACI,QAAS,GAAM,QAAQ,CAAE,CACzC,GAAI,CACFD,cAAc,CAAGV,IAAI,CAACY,KAAK,CAACL,IAAI,CAACI,QAAQ,CAAC,CAC5C,CAAE,MAAOE,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,qCAAqC,CAAEN,IAAI,CAACb,EAAE,CAAEmB,KAAK,CAAC,CACtE,CACF,CAAC,IAAM,CACLH,cAAc,CAAGH,IAAI,CAACI,QAAQ,CAChC,CACA,MAAO,CACL,GAAGJ,IAAI,CACPI,QAAQ,CAAED,cACZ,CAAC,CACH,CAAC,CAAC,CACJ,CAAE,MAAOG,KAAK,CAAE,CACdC,OAAO,CAACC,GAAG,CAAC,iCAAiC,CAAEF,KAAK,CAAC,CACvD,CACF,CAAC,CAGD;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAG,OAAO,CAAG,KAAAA,CAAOb,MAAM,CAAEc,MAAM,GAAK,CAC/C,GAAI,CACF,KAAM,CAAA3B,QAAQ,CAAG,KAAM,CAAAC,KAAK,CAAC,GAAGH,MAAM,SAAS6B,MAAM,EAAE,CAAC,CACxD,KAAM,CAAAV,IAAI,CAAG,KAAM,CAAAjB,QAAQ,CAACE,IAAI,CAAC,CAAC,CAElC,KAAM,CAAA0B,SAAS,CAAGX,IAAI,CAACY,IAAI,CAAEC,CAAC,EAAKA,CAAC,CAACjB,MAAM,GAAKA,MAAM,CAAC,CAEvD,GAAI,CAACe,SAAS,CAAE,CACd,KAAM,IAAI,CAAAG,KAAK,CAAC,+BAA+BlB,MAAM,EAAE,CAAC,CAC1D,CAEA,GAAI,CAAAO,cAAc,CAAG,EAAE,CACvB,GAAI,MAAO,CAAAQ,SAAS,CAACP,QAAQ,GAAK,QAAQ,CAAE,CAC1C,GAAI,CACFD,cAAc,CAAGV,IAAI,CAACY,KAAK,CAACM,SAAS,CAACP,QAAQ,CAAC,CACjD,CAAE,MAAOE,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,qCAAqC,CAAEI,MAAM,CAAEJ,KAAK,CAAC,CACrE,CACF,CAAC,IAAM,CACLH,cAAc,CAAGQ,SAAS,CAACP,QAAQ,CACrC,CACA,MAAO,CACL,GAAGO,SAAS,CACZP,QAAQ,CAAED,cACZ,CAAC,CAEH,CAAE,MAAOG,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,gCAAgC,CAAEA,KAAK,CAAC,CACxD,CACF,CAAC,CAED,MAAO,MAAM,CAAAS,QAAQ,CAAG,KAAO,CAAAf,IAAI,EAAK,CAEtC,GAAI,CACF;AACA,GAAI,CAAAjB,QAAQ,CAAG,KAAM,CAAAC,KAAK,CAAC,GAAGH,MAAM,SAASmB,IAAI,CAACU,MAAM,EAAE,CAAE,CAC1DpB,MAAM,CAAE,KAAK,CACbC,OAAO,CAAE,CACP,cAAc,CAAE,kBAClB,CAAC,CACDC,IAAI,CAAEC,IAAI,CAACC,SAAS,CAACM,IAAI,CAC3B,CAAC,CAAC,CAEF;AACA,GAAIjB,QAAQ,CAACiC,MAAM,GAAK,GAAG,CAAE,CAC3BjC,QAAQ,CAAG,KAAM,CAAAC,KAAK,CAAC,GAAGH,MAAM,QAAQ,CAAE,CACxCS,MAAM,CAAE,MAAM,CACdC,OAAO,CAAE,CACP,cAAc,CAAE,kBAClB,CAAC,CACDC,IAAI,CAAEC,IAAI,CAACC,SAAS,CAACM,IAAI,CAC3B,CAAC,CAAC,CACJ,CAEA;AACA,MAAO,MAAM,CAAAjB,QAAQ,CAACE,IAAI,CAAC,CAAC,CAC9B,CAAE,MAAOqB,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,oBAAoB,CAAEA,KAAK,CAAC,CAC1C,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAGD;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAW,UAAU,CAAG,KAAO,CAAAP,MAAM,EAAK,CAC1C,GAAI,CACF,KAAM,CAAA3B,QAAQ,CAAG,KAAM,CAAAC,KAAK,CAAC,GAAGH,MAAM,SAAS6B,MAAM,EAAE,CAAE,CACvDpB,MAAM,CAAE,QAAQ,CAChBC,OAAO,CAAE,CACP,cAAc,CAAE,kBAClB,CACF,CAAC,CAAC,CACF,GAAIR,QAAQ,CAACiC,MAAM,GAAK,GAAG,CAAE,CAC3BT,OAAO,CAACC,GAAG,CAAC,iCAAiC,CAAC,CAChD,CACA,OACF,CAAE,MAAOF,KAAK,CAAE,CACdC,OAAO,CAACC,GAAG,CAAC,cAAc,CAAC,CAC7B,CACF,CAAC,CAED;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAU,UAAU,CAAG,KAAO,CAAAtB,MAAM,EAAK,CACxC,MAAO,CAAAZ,KAAK,CAAC,GAAGH,MAAM,SAASe,MAAM,EAAE,CAAE,CACvCN,MAAM,CAAE,QAAQ,CAChBC,OAAO,CAAE,CACP,cAAc,CAAE,kBAClB,CACF,CAAC,CAAC,CACN,CAAC,CAED;AAEA,MAAO,MAAM,CAAA4B,aAAa,CAAG,KAAO,CAAAC,SAAS,EAAK,CAChD,GAAI,CACF,KAAM,CAAAC,MAAM,CAAG,KAAM,CAAAC,mBAAmB,CAACF,SAAS,CAAC,CACnDb,OAAO,CAACC,GAAG,CAAC,mBAAmBa,MAAM,EAAE,CAAC,CAExC,GAAIA,MAAM,CAAE,CACV,KAAM,CAAAtC,QAAQ,CAAG,KAAM,CAAAC,KAAK,CAAC,GAAGH,MAAM,YAAYuC,SAAS,EAAE,CAAE,CAC7D9B,MAAM,CAAE,QAAQ,CAChBC,OAAO,CAAE,CACP,cAAc,CAAE,kBAClB,CACF,CAAC,CAAC,CAEF,GAAI,CAACR,QAAQ,CAACwC,EAAE,CAAE,CAChBhB,OAAO,CAACD,KAAK,CAAC,qCAAqCvB,QAAQ,CAACiC,MAAM,EAAE,CAAC,CACvE,CAAC,IAAM,CACLT,OAAO,CAACC,GAAG,CAAC,8BAA8B,CAAC,CAC7C,CAEA,MAAO,CAAAzB,QAAQ,CACjB,CAAC,IAAM,CACLwB,OAAO,CAACC,GAAG,CAAC,wBAAwB,CAAC,CACvC,CACF,CAAE,MAAOF,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,yBAAyB,CAAEA,KAAK,CAAC,CACjD,CACF,CAAC,CAED,MAAO,MAAM,CAAAkB,WAAW,CAAG,KAAO,CAAAC,OAAO,EAAK,CAC5C,KAAM,CAAAJ,MAAM,CAAG,KAAM,CAAAC,mBAAmB,CAACG,OAAO,CAACL,SAAS,CAAC,CAE3D;AACA,GAAI,CAACC,MAAM,CAAE,CACX,GAAI,CAAAtC,QAAQ,CAAG,KAAM,CAAAC,KAAK,CAAC,GAAGH,MAAM,WAAW,CAAE,CAC/CS,MAAM,CAAE,MAAM,CACdC,OAAO,CAAE,CACP,cAAc,CAAE,kBAClB,CAAC,CACDC,IAAI,CAAEC,IAAI,CAACC,SAAS,CAAC+B,OAAO,CAC9B,CAAC,CAAC,CACF,MAAO,MAAM,CAAA1C,QAAQ,CAACE,IAAI,CAAC,CAAC,CAC9B,CAAC,IAAM,CACL;AACA,GAAI,CAAAF,QAAQ,CAAG,KAAM,CAAAC,KAAK,CAAC,GAAGH,MAAM,YAAY4C,OAAO,CAACL,SAAS,EAAE,CAAE,CACnE9B,MAAM,CAAE,KAAK,CACbC,OAAO,CAAE,CACP,cAAc,CAAE,kBAClB,CAAC,CACDC,IAAI,CAAEC,IAAI,CAACC,SAAS,CAAC+B,OAAO,CAC9B,CAAC,CAAC,CACF,MAAO,MAAM,CAAA1C,QAAQ,CAACE,IAAI,CAAC,CAAC,CAC9B,CACF,CAAC,CAED;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAyC,WAAW,CAAG,KAAO,CAAA9B,MAAM,EAAK,CAC3C,GAAI,CACF,KAAM,CAAAb,QAAQ,CAAG,KAAM,CAAAC,KAAK,CAAC,GAAGH,MAAM,WAAW,CAAC,CAClD,KAAM,CAAA8C,QAAQ,CAAG,KAAM,CAAA5C,QAAQ,CAACE,IAAI,CAAC,CAAC,CACtC,MAAO,CAAA0C,QAAQ,CAAC5B,MAAM,CAAE0B,OAAO,EAC7BA,OAAO,CAAC7B,MAAM,GAAKA,MACpB,CAAC,CACJ,CAAE,MAAOU,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,oCAAoC,CAAEA,KAAK,CAAC,CAC5D,CACF,CAAC,CAED,MAAO,MAAM,CAAAgB,mBAAmB,CAAG,KAAO,CAAAF,SAAS,EAAK,CACtD,GAAI,CACF,KAAM,CAAArC,QAAQ,CAAG,KAAM,CAAAC,KAAK,CAAC,GAAGH,MAAM,YAAYuC,SAAS,EAAE,CAAC,CAC9D,MAAO,CAAArC,QAAQ,CAACwC,EAAE,CAAG,IAAI,CAAG,KAAK,CACnC,CAAE,MAAOjB,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,QAAQ,CAAEA,KAAK,CAAC,CAC9B,MAAO,MAAK,CACd,CACF,CAAC,CAED,MAAO,MAAM,CAAAsB,YAAY,CAAG,KAAO,CAAA7C,QAAQ,EAAK,CAC9C,KAAM,CAAA8C,KAAK,CAAG9C,QAAQ,CAAC+C,UAAU,CAEjC,GAAI,CACF,KAAM,CAAAC,cAAc,CAAG,KAAM,CAAA/C,KAAK,CAAC,GAAGH,MAAM,gBAAgB,CAAE,CAC5DS,MAAM,CAAE,MAAM,CACdC,OAAO,CAAE,CACP,cAAc,CAAE,kBAClB,CAAC,CACDyC,WAAW,CAAE,SAAS,CACtBxC,IAAI,CAAEC,IAAI,CAACC,SAAS,CAAC,CAAEmC,KAAM,CAAC,CAChC,CAAC,CAAC,CACFI,YAAY,CAACC,OAAO,CAAC,cAAc,CAAEL,KAAK,CAAC,CAC3C,MAAO,MAAM,CAAAE,cAAc,CAAC9C,IAAI,CAAC,CAAC,CACpC,CAAE,MAAOqB,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,eAAe,CAAEA,KAAK,CAAC,CACvC,CACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}